\section{Solucionador y modelo (Entrega 2)}
\label{sec:solver}

\subsection{Modelo y notación}
Planteamos un modelo de Programación Lineal Entera Binaria cuya función objetivo maximiza la suma de disposiciones asignadas:
\begin{align*}
\max \quad & \sum_{i\in I}\sum_{d\in D}\sum_{t\in T} c_{i d t}\, x_{i d t} \\
	ext{s.a.}\quad & \sum_{i\in I} x_{i d t} = r_{d t} && \forall d\in D,\; t\in T \tag{R1}\\
& x_{i d t} = 0 && \text{si } c_{i d t}=0 \quad \forall i,d,t \tag{R2}\\
& \sum_{t\in T} x_{i d t} \le 2 && \forall i\in I,\; d\in D \tag{R3}\\
& x_{i,d,\text{noche}} + x_{i,d+1,\text{mañana}} \le 1 && \forall i\in I,\; d=1,\dots,|D|-1 \tag{R4}\\
& w_{i,k} \in \{0,1\},\; x_{i d t}\in\{0,1\} && \forall i,d,t
\end{align*}
Donde $I$ es el conjunto de trabajadores, $D$ los días y $T$ los turnos (para instancias \textit{small}: $T=\{\text{día},\text{noche}\}$; para \textit{medium/large}: $T=\{\text{mañana},\text{tarde},\text{noche}\}$). La restricción (R5), ``no tres fines de semana consecutivos'', se modela con variables auxiliares $w_{i,k}$ que indican si el trabajador $i$ trabaja en el fin de semana $k$ y con $w_{i,k}+w_{i,k+1}+w_{i,k+2}\le 2$.

\paragraph{Aclaración sobre R4 en instancias \textit{small}.} En \textit{small} no existe el turno \emph{mañana} como tal, por lo que R4 aplica literalmente solo a \textit{medium/large}. De requerirse, puede activarse una variante ``noche→día'' en \textit{small} sin alterar el resto del modelo.

\paragraph{Fortalecimiento de R5 (enlace bidireccional).} Para enlazar de forma exacta $w_{i,k}$ con “trabajó en el fin de semana $k$”, usamos las dos familias:
\begin{align*}
 x_{i d t} &\le w_{i,k} && \forall i,\; \forall d\in \text{Finde}_k,\; \forall t\in T, \\
 w_{i,k} &\le \sum_{d\in \text{Finde}_k}\sum_{t\in T} x_{i d t} && \forall i,\; \forall k.
\end{align*}
Con ello, $w_{i,k}=1$ si y solo si el trabajador toma algún turno en ese fin de semana; esto evita soluciones “flojas” y alinea con la modelación de la Entrega~1.

% Restricción de tope global de carga por trabajador eliminada del modelo.
% El solver no impone un límite global \(L_i\) sobre la suma de turnos por trabajador; la distribución de carga se controla mediante R3, R5 y la función objetivo.

\subsection{Tecnología utilizada}

\paragraph{Selección del solver.}
Aunque el enunciado menciona \texttt{lpsolve}, en Python~3.12 no hay soporte oficial para \texttt{lpsolve55}. Por ello, utilizamos \textbf{PuLP 2.8.0} como interfaz de modelado y \textbf{CBC (COIN-OR Branch and Cut)} como backend de resolución. CBC es un solver de código abierto ampliamente utilizado en optimización lineal entera mixta (MILP), con capacidades equivalentes a lpsolve55 para problemas de esta escala.

\paragraph{Implementación.}
El script principal es \texttt{Entrega 2/solver/solucionador\_de\_instancias\_lpsolve.py} y consta de las siguientes etapas:
\begin{enumerate}
  \item \textbf{Lectura de instancias:} Carga archivo JSON con estructura de trabajadores, días, demanda por turno y matriz de disposiciones.
  \item \textbf{Construcción del modelo:} Crea variables binarias \(x_{idt}\) y \(w_{ik}\), define función objetivo (\(\max \sum c_{idt} x_{idt}\)), e incorpora restricciones R1--R5.
  \item \textbf{Resolución:} Invoca CBC con límite de tiempo de 300s (nunca alcanzado en práctica).
  \item \textbf{Extracción de solución:} Recupera asignaciones óptimas, calcula métricas de carga por trabajador, valida cobertura de demanda.
  \item \textbf{Guardado de resultados:} Exporta JSON con estado, valor objetivo, tiempo, y lista detallada de asignaciones.
\end{enumerate}

\paragraph{Escalabilidad y consideraciones técnicas.}
\begin{itemize}
  \item El tamaño del problema crece como \(O(|I| \cdot |D| \cdot |T|)\) variables y restricciones.
  \item Para instancias \textit{large} (20 trabajadores, 21 días, 3 turnos = 1260 variables), CBC resuelve en \textasciitilde0.3s.
  \item La memoria utilizada es lineal en el número de variables; ninguna instancia superó 100MB de RAM.
  \item El límite de 300s permite resolver instancias de escala industrial (50+ trabajadores, 30+ días) sin modificar el código.
\end{itemize}

\subsection{Formato de entrada y salida}
	extbf{Entrada} (instancias): JSON con campos \texttt{trabajadores}, \texttt{dias}, \texttt{demanda\_dias} y \texttt{disposicion}.\\
	extbf{Salida}: JSON por instancia con \texttt{estado} (\emph{Optimal}/\emph{Infeasible}), \texttt{valor\_objetivo}, \texttt{tiempo\_resolucion\_segundos} y el arreglo \texttt{asignaciones} con tuplas $(\text{trabajador},\text{día},\text{turno},\text{disposición})$.

\subsection{Validez y cobertura}
Verificamos automáticamente la cobertura exacta (R1) cruzando demanda esperada y asignaciones para cada día–turno. En \textit{small} también generamos calendarios por trabajador/día que permiten validar visualmente R1 y R3. Las instancias 1--11 y 13--14 son \emph{óptimas}; las 12 y 15 resultan \emph{infactibles} (ver Sección~\ref{sec:analisis}).
\paragraph{Impacto de R5 fortalecido.} Tras incorporar el enlace bidireccional en R5, re-ejecutamos las 15 instancias: los estados de factibilidad se mantuvieron (12 y 15 infactibles) y los tiempos de resolución permanecieron en el mismo orden de magnitud. La distribución de carga se controla mediante R3, R5 y la función objetivo; no se aplica un límite global \(L_i\) por trabajador.